// Selection to MXMLG (ctrl alt cmd f)

/*
* v0.1.2
*
* allow you export MXML skin for Apache Flex spark Button
*
»»» radialGradient
*
* TODO :
* - shadows , innerShadows
* - multistates
* - gradient angle
* - radial gradient x, y, foalCenterPoint
* - lines, path, ellipse
* - img ( icons )
* - multi-resolution
* - labelDisplay properties : color, fontSize
*/
log("Plugin getSelectionMXMLG started...");

/***************
* OBJECTS
*************** */

/*
* gestionnaire de tabulation
*/
var T = {
	value:0,
	add:function(){ this.value ++ ;},
	rm:function(){ this.value --  ;},
	tab:function(){
			var t = "";
			for(var i = 0 ; i < this.value ; i++){
				t += "\t";
			}
			return t; },
}

var ND = " >\n";
var _ND = " />\n";

/*
* gestionnaire de clipboard
*/
var clipboard = {
	board: NSPasteboard.generalPasteboard(),

	copy:function( value )
	{
		this.board.declareTypes_owner( [ NSPasteboardTypeString ], null );
		this.board.setString_forType( value , NSPasteboardTypeString );	
	}
}

/**
* gestionnaire d'alerte
*/
var Al = {
	show:function( bt1Label, bt2Label, title, info ){
		var alert = [[NSAlert alloc] init];
		[alert addButtonWithTitle:bt1Label];

		if( bt2Label != null )
			[alert addButtonWithTitle:bt2Label];

		if( title != null)
			[alert setMessageText:title];

		if( info != null)
			[alert setInformativeText:info];

		if( ! bt2Label )
			[alert setAlertStyle:NSInformationalAlertStyle];		
		else
			[alert setAlertStyle:NSWarningAlertStyle];		

		var choice = [alert runModal];
		[alert release];
		return choice == NSAlertFirstButtonReturn ? 1 : 2;
	}
};


/***************
* FUNCTIONS
*************** */

/*
* returns MXML description of a layer / shape / Rectangle
*/
function getMXML(layer, setLocalPosition)
{
	log( "getMXML()..." );

	// rect coord
	var item = [layer frame];
	var rect = getItemRect(item, setLocalPosition);

	// <
	var itML = "<s:Rect ";
	itML += "width=\"" + rect.width + "\" " + "height=\"" + rect.height + "\" " + "x=\"" + rect.x + "\" " + "y=\"" + rect.y + "\" ";
	
	// styles
	var itemStyle = [layer style];
	itML += getOpacityAttribute(itemStyle);
	itML += getRadiusAttribute(layer);

	// Rect>
	itML += ND;
	T.add();

	// stroke
	var itemBorders = [itemStyle borders];	
	itML += getStrokeNode( itemBorders[0]);

	// fill
	var itemFills = [itemStyle fills];
	itML += getFillNode( itemFills[0]);
	T.rm();

	// </
	itML += "</s:Rect>";

	return itML;
}

/*
* item rect coordinates
*/
function getItemRect( item , setLocalPosition)
{
	var rect = {};
	rect.width = [item width];
	rect.height = [item height];

	rect.x = setLocalPosition ? 0 : [item x];
	rect.y = setLocalPosition ? 0 : [item y];
	return rect;
}

/*
* return style opacity
*/
function getOpacityAttribute( style )
{
	log("getOpacityAttribute()..." );
	
	var gfxContext = [style contextSettings];
	var o = [gfxContext opacity];
	log("Opacity : " + o );
	
	return " alpha=\"" + o + "\" ";
}

function getRadiusAttribute(layer)
{
	log("getRadiusAttribute()...");
	var radius = [[[layer layers] firstObject] fixedRadius];
	var rd = " radiusX=\"" + radius + "\" ";
	rd += " radiusY=\"" + radius + "\" ";
	log("radius : " + radius );
	
	return rd;
}

function getAlphaAttribute(color){
	log("getAlphaAttribute()...");
	var colorAlpha = [color alpha];
	log('alpha : ' + colorAlpha );
	a = " alpha=\""+ colorAlpha +"\" ";

	return a;
}


function getStrokeNode(border){
	log("getStrokeNode...");
	var strokeChain = T.tab() + "<s:stroke>\n";
	var borderType = [border fillType];

	if( borderType == 0 ){
		var borderColor = [border color];
		var hexColor = [borderColor hexValue];
		log('hexValue : ' + hexColor);

		T.add();
		strokeChain += T.tab() + "<s:SolidColorStroke color=\"#" + hexColor + "\" ";
		strokeChain += getAlphaAttribute(borderColor);		
		strokeChain += _ND;
		T.rm();
		
	} else if( borderType == 1 ) // gradient
	{
		var gradient = [border gradient];
		var gradientType = [gradient gradientType];
		var isRadial = (gradientType == 1 );
		strokeChain += getGradientNode(gradient, isRadial, true);		
	} else {
		log("!!! ERROR !!!")
	}

	strokeChain += T.tab() + "</s:stroke>\n";

	return strokeChain;
}


function getFillNode(fill)
{
	log("getFillNode...");

	var fillChain = T.tab() + "<s:fill>\n";
	var fillType = [fill fillType];

	if( fillType == 0 ) // solid color
	{
		var fillColor = [fill color];
		var hexColor = [fillColor hexValue];
		log('hexValue : ' + hexColor);

		T.add();
		fillChain += T.tab() + "<s:SolidColor color=\"#" + hexColor + "\" ";
		fillChain += getAlphaAttribute(fillColor);

		fillChain += _ND;
		T.rm();
		
	} else if( fillType == 1 ) // gradient
	{
		var gradient = [fill gradient];
		var gradientType = [gradient gradientType];
		var isRadial = (gradientType == 1 );
		fillChain += getGradientNode(gradient,isRadial, false);		
	} else {
		log("!!! ERROR !!!")
	}

	fillChain += T.tab() + "</s:fill>\n";	

	return fillChain;
}

/**
* 
	<s:LinearGradient[isStroke? "Stroke"] rotation="90" >
		<s:GradientEntry color="#AAAAAA" ratio="0" alpha="1"  />
		<s:GradientEntry color="#FF0000" ratio="1" alpha=".5"  />
	</s:LinearGradient[isStroke? "Stroke"]>
*/
function getGradientNode(gradient, isRadial, isStroke )
{
	log("getGradientNode()...");

	var strokeSufx = isStroke ? 'Stroke' : "";
	var gradientType = isRadial ? 'Radial' : "Linear";

	var lg = "<s:"+ gradientType +"Gradient"+strokeSufx+">\n";
	T.add();

	lg += getGradientEntriesNodes(gradient);

	T.rm();
	lg += "</s:"+ gradientType +"Gradient"+strokeSufx+">\n";

	log(lg);
	return lg;
}

function getGradientEntriesNodes(gradient)
{
	log("getGradientEntriesNodes()...");
	var entries = '';
	var gradientEntries = [gradient stops];
	var numEntries = gradientEntries.length();
	log("numEntries : " + numEntries);
	
	for( var i = 0 ; i < numEntries ; i++)
	{
		entry = gradientEntries[i];
		var entryColor = [[entry color] hexValue];
		log("entry hex : " + entryColor);
		entries += T.tab() +  "<s:GradientEntry color=\"#" + entryColor + "\" ";

		var entryPos = [entry position];
		log("entry pos : " + entryPos);
		entries += "ratio=\"" + entryPos+ "\" ";

		var entryAlpha = [[entry color] alpha];
		log("entry alpha : " + entryAlpha);
		entries += "alpha=\"" + entryAlpha + "\" />";
	}
	
	log(entries);

	return entries;
}

// 

/*
* COORDINATES POS
*/
var setLocalPosition;
var LOCAL_POS_INFO = "Coordonnées locales : origine x,y = coin haut gauche de la selection";
var LOCAL_POS_TITLE = "Voulez-vous utiliser les coordonnées locales de la sélection ?";
setLocalPosition = Al.show( "Oui", "Non", LOCAL_POS_TITLE, LOCAL_POS_INFO);

/*
* EXPORT LES ITEMS DE LA SELECTION
*/
var res = "";

for (var i=0; i<selection.length(); i++) {

	log("setLocalPosition : " + setLocalPosition);

	var layer = selection[i];

	res += getMXML(layer, setLocalPosition);
}

clipboard.copy( res );
log("*** MXML complete ! ***");
log(res);	