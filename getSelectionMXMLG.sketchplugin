// Selection to MXMLG (ctrl alt cmd f)

/*
* v0.1.2
*
* allow you export MXML skin for Apache Flex spark Button
*
»»» 
*
* TODO :
* - shadows , innerShadows
* - multistates
* - gradient angle
* - radial gradient x, y, foalCenterPoint
* - lines, path, ellipse
* - img ( icons )
* - multi-resolution
* - labelDisplay properties : color, fontSize
*/
log("Plugin getSelectionMXMLG started...");

/***************
* OBJECTS
*************** */

/*
* gestionnaire de tabulation
*/
var T = {
	value:0,
	add:function(){ this.value ++ ;},
	rm:function(){ this.value --  ;},
	tab:function(){
			var t = "";
			for(var i = 0 ; i < this.value ; i++){
				t += "\t";
			}
			return t; },
}

var ND = " >\n";
var _ND = " />\n";

/*
* gestionnaire de clipboard
*/
var clipboard = {
	board: NSPasteboard.generalPasteboard(),

	copy:function( value )
	{
		this.board.declareTypes_owner( [ NSPasteboardTypeString ], null );
		this.board.setString_forType( value , NSPasteboardTypeString );	
	}
}

/**
* gestionnaire d'alerte
*/
var Al = {
	show:function( bt1Label, bt2Label, title, info ){
		var alert = [[NSAlert alloc] init];
		[alert addButtonWithTitle:bt1Label];

		if( bt2Label != null )
			[alert addButtonWithTitle:bt2Label];

		if( title != null)
			[alert setMessageText:title];

		if( info != null)
			[alert setInformativeText:info];

		if( ! bt2Label )
			[alert setAlertStyle:NSInformationalAlertStyle];		
		else
			[alert setAlertStyle:NSWarningAlertStyle];		

		var choice = [alert runModal];
		[alert release];
		return choice == NSAlertFirstButtonReturn ? 1 : 2;
	}
};


/***************
* FUNCTIONS
*************** */


function getSelectionOriginRect(){
	var rect = {};

	rect.x = 10;

	var numItems = [selection length];
	log(numItems);

	var layer;
	var minX, minY;
	var maxX, maxY;
	var itemX, itemY;
	var itemW, itemH;

	// determine x y min
	for( var i = 0 ; i < numItems ; i ++){
		layer = selection[i];
		itemX = [[layer frame] x];
		itemY = [[layer frame] y];
		itemW = [[layer frame] width];
		itemH = [[layer frame] height];
		if( i == 0){
			minX = itemX;
			minY = itemY;
			maxX = itemX + itemW;
			maxY = itemY + itemH;
		} else {
			minX = Math.min(itemX , minX);
			minY = Math.min(itemY , minY);
			maxX = Math.max(itemX + itemW , maxX);
			maxY = Math.max( itemY + itemH , maxY );
		}
	}

	rect.x = minX;
	rect.y = minY;
	rect.width = maxX - minX;
	rect.height = maxY - minY;

	return rect;
}

/*
* returns MXML description of a layer / shape / Rectangle
*/
function getMXML(layer, setLocalPosition, localCenter)
{
	log( "getMXML()..." );

	// rect coord
	var item = [layer frame];
	var rect = getItemRect(item, setLocalPosition, localCenter);

	// <
	var itML = "<s:Rect ";
	itML += "width=\"" + rect.width + "\" " + "height=\"" + rect.height + "\" " + "x=\"" + rect.x + "\" " + "y=\"" + rect.y + "\" ";
	
	// styles
	var itemStyle = [layer style];
	itML += getOpacityAttribute(itemStyle);
	itML += getRadiusAttribute(layer);

	// Rect>
	itML += ND;
	T.add();

	// stroke
	var itemBorders = [itemStyle borders];	
	itML += getStrokeNode( itemBorders[0]);

	// fill
	var itemFills = [itemStyle fills];
	itML += getFillNode( itemFills[0]);
	T.rm();

	// </
	itML += "</s:Rect>";

	return itML;
}

/*
* item rect coordinates
*/
function getItemRect( item , setLocalPosition, localCenter)
{
	var rect = {};
	rect.width = [item width];
	rect.height = [item height];

	var itemX = [item x];
	var itemY = [item y];
	rect.x = setLocalPosition ? itemX - localCenter.x : itemX;
	rect.y = setLocalPosition ? itemY - localCenter.y : itemY;
	return rect;
}

/*
* return style opacity
*/
function getOpacityAttribute( style )
{
	log("getOpacityAttribute()..." );
	
	var gfxContext = [style contextSettings];
	var o = [gfxContext opacity];
	log("Opacity : " + o );
	
	return " alpha=\"" + o + "\" ";
}

function getRadiusAttribute(layer)
{
	log("getRadiusAttribute()...");
	var radius = [[[layer layers] firstObject] fixedRadius];
	var rd = " radiusX=\"" + radius + "\" ";
	rd += " radiusY=\"" + radius + "\" ";
	log("radius : " + radius );
	
	return rd;
}

function getAlphaAttribute(color){
	log("getAlphaAttribute()...");
	var colorAlpha = [color alpha];
	log('alpha : ' + colorAlpha );
	a = " alpha=\""+ colorAlpha +"\" ";

	return a;
}


function getStrokeNode(border){
	log("getStrokeNode...");
	var strokeChain = T.tab() + "<s:stroke>\n";
	var borderType = [border fillType];

	if( borderType == 0 ){
		var borderColor = [border color];
		var hexColor = [borderColor hexValue];
		log('hexValue : ' + hexColor);

		T.add();
		strokeChain += T.tab() + "<s:SolidColorStroke color=\"#" + hexColor + "\" ";
		strokeChain += getAlphaAttribute(borderColor);		
		strokeChain += _ND;
		T.rm();
		
	} else if( borderType == 1 ) // gradient
	{
		var gradient = [border gradient];
		var gradientType = [gradient gradientType];
		var isRadial = (gradientType == 1 );
		strokeChain += getGradientNode(gradient, isRadial, true);		
	} else {
		log("!!! ERROR !!!")
	}

	strokeChain += T.tab() + "</s:stroke>\n";

	return strokeChain;
}


function getFillNode(fill)
{
	log("getFillNode...");

	var fillChain = T.tab() + "<s:fill>\n";
	var fillType = [fill fillType];

	if( fillType == 0 ) // solid color
	{
		var fillColor = [fill color];
		var hexColor = [fillColor hexValue];
		log('hexValue : ' + hexColor);

		T.add();
		fillChain += T.tab() + "<s:SolidColor color=\"#" + hexColor + "\" ";
		fillChain += getAlphaAttribute(fillColor);

		fillChain += _ND;
		T.rm();
		
	} else if( fillType == 1 ) // gradient
	{
		var gradient = [fill gradient];
		var gradientType = [gradient gradientType];
		var isRadial = (gradientType == 1 );
		fillChain += getGradientNode(gradient,isRadial, false);		
	} else {
		log("!!! ERROR !!!")
	}

	fillChain += T.tab() + "</s:fill>\n";	

	return fillChain;
}

/**
* export chaine de représentation d'un dégradé
* @param gradient MSGradient
* @param isRadial Bool
* @param isStroke Bool
* exemple :
	<s:[isRadial?Radial:Linear]Gradient[isStroke?Stroke:] rotation="90" >
		<s:GradientEntry color="#AAAAAA" ratio="0" alpha="1"  />
		<s:GradientEntry color="#FF0000" ratio="1" alpha=".5"  />
	</s:LinearGradient[isStroke? "Stroke"]>
*/
function getGradientNode(gradient, isRadial, isStroke )
{
	log("getGradientNode()...");

	var strokeSufx = isStroke ? 'Stroke' : "";
	var gradientType = isRadial ? 'Radial' : "Linear";

	var lg = "<s:"+ gradientType +"Gradient"+strokeSufx+">\n";
	T.add();

	lg += getGradientEntriesNodes(gradient);

	T.rm();
	lg += "</s:"+ gradientType +"Gradient"+strokeSufx+">\n";

	log(lg);
	return lg;
}

function getGradientEntriesNodes(gradient)
{
	log("getGradientEntriesNodes()...");
	var entries = '';
	var gradientEntries = [gradient stops];
	var numEntries = gradientEntries.length();
	log("numEntries : " + numEntries);
	
	for( var i = 0 ; i < numEntries ; i++)
	{
		entry = gradientEntries[i];
		var entryColor = [[entry color] hexValue];
		log("entry hex : " + entryColor);
		entries += T.tab() +  "<s:GradientEntry color=\"#" + entryColor + "\" ";

		var entryPos = [entry position];
		log("entry pos : " + entryPos);
		entries += "ratio=\"" + entryPos+ "\" ";

		var entryAlpha = [[entry color] alpha];
		log("entry alpha : " + entryAlpha);
		entries += "alpha=\"" + entryAlpha + "\" />";
	}
	
	log(entries);

	return entries;
}

// 

/*
* COORDINATES POS
*/
var setLocalPosition;
var LOCAL_POS_INFO = "Coordonnées locales : origine x,y = coin haut gauche de la selection";
var LOCAL_POS_TITLE = "Voulez-vous utiliser les coordonnées locales de la sélection ?";
setLocalPosition = Al.show( "Oui", "Non", LOCAL_POS_TITLE, LOCAL_POS_INFO);

var localCenter = {x:0,y:0};
if( setLocalPosition )
	 localCenter = getSelectionOriginRect();

/*
* BUILD MXML CHAIN FOR SELECTION
*/
var res = "";

for (var i=0; i<selection.length(); i++) {

	log("setLocalPosition : " + setLocalPosition);

	var layer = selection[i];

	res += getMXML(layer, setLocalPosition, localCenter);
}

/*
* EXPORT TO CLIPBOARD & LOG
*/
clipboard.copy( res );
log("*** MXML complete ! ***");
log(res);	
Al.show('OK', null, "Export MXML", "Completed");


